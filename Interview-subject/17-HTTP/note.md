## HTTP是什么？

**HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**

在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。

### 要点小结

* HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。
* HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。
* HTTP 传输的是文字、图片、音频、视频等超文本数据。
* HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。


---------------------------------------------------------------------------------------------------------------

## HTTP的前世今生

### HTTP/0.9
HTTP/0.9 是个简单的文本协议，只能获取文本资源；

* 只有一个请求行，并没有 **HTTP 请求头和请求体**;
* 服务器也没有返回头信息;
* 文件内容是以 ASCII 字符流来传输;

### HTTP/1.0
HTTP/1.0 确立了大部分现在使用的技术，但它不是正式标准；

* 增加了 HEAD、POST 等新方法；
* 增加了响应状态码，标记可能的错误原因；
* 引入了协议版本号概念；
* 引入了 HTTP Header（头部）的概念，
* 让 HTTP 处理请求和响应更加灵活；传输的数据不再仅限于文本。

### HTTP/1.1
HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；

* 增加了 PUT、DELETE 等新的方法；
* 增加了缓存管理和控制；
* 明确了连接管理，允许持久连接；
* 允许响应数据分块（chunked），利于传输大文件；
* 强制要求 Host 头，让互联网主机托管成为可能。

### HTTP/2
HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；

* 二进制协议，不再是纯文本（二进制）；
* 可发起多个请求，废弃了 1.1 里的管道（多路复用 - **一个域名只使用一个 TCP 连接**）；
* 使用专用算法压缩头部，减少数据传输量（头部压缩）；
* 允许服务器主动向客户端推送数据（服务端推送）；
* 增强了安全性，“事实上”要求加密通信（安全性）。

### HTTP/3
HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。HTTP/3 中的 QUIC 协议集合了以下几点功能：

* 实现了类似 TCP 的流量控制、传输可靠性的功能。
* 集成了 TLS 加密功能。
* 实现了 HTTP/2 中的多路复用功能。
* 实现了快速握手功能。


## 网络分层模型（四层）

### TCP/IP 网络分层模型
* 应用层（第四层）
* 传输层（第三层）
* 网络层（第二层）
* 链路层（第一层）


## HTTP请求方法
HTTP/1.1 规定了八种方法，单词都必须是大写的形式：

* 常用方法：
    - GET：获取资源，可以理解为读取或者下载数据；
    - HEAD：获取资源的元信息；
    - POST：向资源提交数据，相当于写入或上传数据；
    - PUT：类似 POST；

* 非常用方法：
    - DELETE：删除资源；
    - CONNECT：建立特殊的连接隧道；
    - OPTIONS：列出可对资源实行的方法；
    - TRACE：追踪请求 - 响应的传输路径。

### 要点小结

* 请求方法是客户端发出的、要求服务器执行的、对资源的一种操作；
* 请求方法是对服务器的“指示”，真正应如何处理由服务器来决定；
* 最常用的请求方法是 GET 和 POST，分别是获取数据和发送数据；
* HEAD 方法是轻量级的 GET，用来获取资源的元信息；
* PUT 基本上是 POST 的同义词，多用于更新数据；
* “安全”与“幂等”是描述请求方法的两个重要属性，具有理论指导意义，可以帮助我们设计系统。

---------------------------------------------------------------------------------------------------------------


## 响应状态码

* 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
    - "101 Switching Protocols"（切换协议，客户端头部发送`Upgrade`字段）

* 2××：成功，报文已经收到并被正确处理；
    - "200 OK"（成功）
    - "204 No Content"（没有 body 数据）
    - "206 Partial Content"（部分内容，通常伴随着响应头字段`Content-Range`）

* 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
    - "301 Moved Permanently"（永久重定向，通过响应头字段`Location`来指定要跳转的URI）
    - "302 Found"（临时重定向，通过响应头字段`Location`来指定要跳转的URI）
    - "304 Not Modified"（缓存重定向，通过`If-Modified-Since`等字段控制）

* 4××：客户端错误，请求报文有误，服务器无法处理；
    - "400 Bad Request"（4xx通用错误码）
    - "403 Forbidden"（表示服务器禁止访问的资源）
    - "404 Not Found"（资源不存在）
    - "405 Method Not Allowed"（不允许的请求方法）

* 5××：服务器错误，服务器在处理请求时内部发生了错误。
    - "500 Internal Server Error"（5xx通用错误码）
    - "501 Not Implemented"（表示客户端请求的功能还不支持）
    - "502 Bad Gateway"（表示服务器作为网关或者代理时返回的错误码）
    - "503 Service Unavailable"（表示服务器繁忙，暂时无法响应服务，通常配合`Retry-After`字段告知客户端多久后重试）

### 要点小结

* 状态码在响应报文里表示了服务器对请求的处理结果；
* 状态码后的原因短语是简单的文字描述，可以自定义；
* 状态码是十进制的三位数，分为五类，从 100 到 599；
    - 1xx类状态码表示协议处理的中间状态，还需要后续操作，比如101：协议升级；
    - 2××类状态码表示成功，常用的有 200、204、206；
    - 3××类状态码表示重定向，常用的有 301、302、304；
    - 4××类状态码表示客户端错误，常用的有 400、403、404；
    - 5××类状态码表示服务器错误，常用的有 500、501、502、503。

---------------------------------------------------------------------------------------------------------------

## HTTP有哪些特点？
* 灵活可扩展
* 可靠传输
* 应用层协议
* 请求-应答
* 无状态（注意：TCP 协议是**有状态**的，`CLOSED - ESTABLISHED - FIN-WAIT - CLOSED`）

### 要点小结
* HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
* HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
* HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
* HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
* HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。


---------------------------------------------------------------------------------------------------------------

## HTTP有哪些优缺点？

* [优点] - 简单、灵活、易于扩展（自定义header，不限于底层协议）
* [优点] - 应用广泛，环境成熟（跨语言、跨平台）
* [优点/缺点] - 无状态（优点：方便组建服务器集群，便于负载均衡；缺点：无法支持需要连续多个步骤的“事务”操作）
* [优点/缺点] - 明文（优点：易于分享信息，方便阅读与修改；缺点：容易被窥视）
* [缺点] - 不安全（缺乏“身份认证”和“完整性校验”）
* [缺点] - 性能不高（不算差，不够好）

### 要点小结

* HTTP 最大的优点是简单、灵活和易于扩展；
* HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；
* HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；
* HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
* HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；
* HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。


---------------------------------------------------------------------------------------------------------------


## 强缓存

* expires：过期时间，服务端的绝对时间，如果客户端与服务端的时间相差很大，会存在误差，http/1.1 后使用Cache-Control。
* Cache-Control：
    - max-age: 过期时间，单位：秒(s)，max-age=n 声明该资源在加载后的 n 秒内都直接使用缓存，使用的是相对时间；
    - private：仅浏览器可以缓存；
    - public：浏览器和代理服务器都可以缓存；
    - no-cache: 不进行**强缓存**；
    - no-store: 不进行**任何缓存**；

## 协商缓存

触发条件：当Cache-Control中的值为no-cache（不进行强缓存）或者max-age的值过期的时候。

### 最后更新时间
* Last-Modified：服务器返回的响应头字段，服务端时间。
* If-Modified-Since：客户端将Last-Modified的值传给服务端进行校验。

### 文件内容的hash值
* ETag：服务端返回的文件内容的hash值；
* If-None-Match：客户端将ETag的值传给服务端进行校验。


## 浏览器缓存位置：
* from memory: 浏览器优化，基于preload；
* from disk: 即HTTP cache缓存的位置；
* service worker：浏览器提供的一种手动操作缓存的方式。

PS：经过Service Worker的 fetch 方法获取的资源，即便她没有命中Service Worker缓存，甚至实际走了网络请求，
也会标注为from serviceworker。



## HTTP2特性概览

* 头部压缩 - 通过键值对维护首部表，由客户端和服务端共同维护，只发送差异化数据
* 二进制格式 - 二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放实体数据。
* 多路复用 - **多个往返通信都复用一个TCP连接来处理**（HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息）。
* 服务器推送 - 基于请求的多个响应

---------------------------------------------------------------------------------------------------------------

## HTTP/2内核剖析

### 连接前言
TLS 握手成功之后，客户端必须要发送一个“连接前言”（connection preface），用来确认建立 HTTP/2 连接。

### 头部压缩
“HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。

伪头字段 - 为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，称之为“伪头字段”（pseudo-header fields）。

为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。

### 二进制帧
HTTP/2 的帧通常不超过 16K，最大是 16M。
HTTP/2 总共定义了 10 种类型的帧，还可以通过扩展自定义帧。

#### 帧类型
* 数据帧
    - DATA 帧(类型 = 0x0)：可以传输与流相关联的任意可变长度的八位字节序列（存放 HTTP 报文）。
    - HEADERS 帧(类型 = 0x1) ：用于打开一个流，负载（payload）里面存放的是被 HPACK 算法压缩的头部信息（存放 HTTP 报文）。
* 控制帧
    - PRIORITY 帧(类型 = 0x2)：指定了 stream 流的发送方的建议优先级（表示设置了流的优先级）。
    - RST_STREAM 帧(类型 = 0x3)允许立即终止一个 stream 流。
    - SETTINGS 帧(类型 = 0x4)：传递影响端点通信方式的配置参数，例如设置对端行为的首选项和约束。
    - PUSH_PROMISE 帧(类型 = 0x5)：用于在发送方打算发起的流之前提前通知对端。
    - PING 帧(类型 = 0x6)：用于测量来自发送方的最小往返时间以及确定空闲连接是否仍然起作用的机制。
    - GOAWAY 帧(类型 = 0x7)：优雅的终止连接或者通知错误（关闭 TCP 连接）。
    - WINDOW_UPDATE 帧(类型 = 0x8)：用于实现流量控制。
    - CONTINUATION 帧(类型 = 0x9)：用于继续一系列 `header block fragments` 头块片段，专门用于**传递较大 HTTP 头部时的持续帧**。

#### 帧标志
* END_HEADERS - 表示头数据结束，相当于 HTTP/1 里头后的空行（“\r\n”）；
* END_STREAM - 表示单方向数据发送结束（即 EOS，End of Stream），相当于 HTTP/1 里 Chunked 分块结束标志（“0\r\n\r\n”）；

#### 流标识符（Stream ID）
流标识符：也就是**帧所属的“流”**，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”。

### 流与多路复用
**流是二进制帧的双向传输序列。**

在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流 ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序。
在概念上，**一个 HTTP/2 的流就等同于一个 HTTP/1 里的“请求 - 应答”。**